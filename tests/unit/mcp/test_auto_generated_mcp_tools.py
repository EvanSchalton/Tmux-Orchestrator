"""
Test suite for the 6 auto-generated MCP tools from CLI reflection.

Tests all core auto-generated tools: list, status, quick-deploy, spawn-orc, execute, reflect
Validates MCP client compatibility and tool functionality.
"""

import json
import subprocess
import time

import pytest


class TestAutoGeneratedMCPTools:
    """Test the 6 core auto-generated MCP tools."""

    def test_mcp_server_generates_all_6_tools(self, test_uuid: str) -> None:
        """Verify that MCP server generates all 6 expected tools."""
        result = subprocess.run(
            ["timeout", "5", "python", "-m", "tmux_orchestrator.mcp_server"], capture_output=True, text=True
        )

        # Check that all 6 tools are generated
        expected_tools = [
            "execute → tmux-orc execute",
            "list → tmux-orc list",
            "quick_deploy → tmux-orc quick-deploy",
            "reflect → tmux-orc reflect",
            "spawn_orc → tmux-orc spawn-orc",
            "status → tmux-orc status",
        ]

        for tool in expected_tools:
            assert tool in result.stderr, f"Tool '{tool}' not generated - Test ID: {test_uuid}"

        # Verify server starts successfully
        assert "Starting FastMCP server" in result.stderr, f"MCP server failed to start - Test ID: {test_uuid}"

    def test_list_tool_cli_execution(self, test_uuid: str) -> None:
        """Test that list tool can execute the underlying CLI command."""
        # Test the CLI command that the MCP tool will execute
        result = subprocess.run(["tmux-orc", "list", "--json"], capture_output=True, text=True, timeout=5)

        assert result.returncode == 0, f"List command failed - Test ID: {test_uuid}"

        # Verify JSON output
        try:
            data = json.loads(result.stdout)
            assert isinstance(data, list), f"List should return array - Test ID: {test_uuid}"
        except json.JSONDecodeError:
            pytest.fail(f"List command returned invalid JSON - Test ID: {test_uuid}")

    def test_status_tool_cli_execution(self, test_uuid: str) -> None:
        """Test that status tool can execute the underlying CLI command."""
        result = subprocess.run(["tmux-orc", "status", "--json"], capture_output=True, text=True, timeout=5)

        assert result.returncode == 0, f"Status command failed - Test ID: {test_uuid}"

        # Verify JSON output structure
        try:
            data = json.loads(result.stdout)
            assert isinstance(data, dict), f"Status should return object - Test ID: {test_uuid}"
            assert "sessions" in data, f"Status missing sessions field - Test ID: {test_uuid}"
            assert "agents" in data, f"Status missing agents field - Test ID: {test_uuid}"
        except json.JSONDecodeError:
            pytest.fail(f"Status command returned invalid JSON - Test ID: {test_uuid}")

    def test_reflect_tool_cli_execution(self, test_uuid: str) -> None:
        """Test that reflect tool can execute the underlying CLI command."""
        result = subprocess.run(["tmux-orc", "reflect", "--format", "json"], capture_output=True, text=True, timeout=5)

        assert result.returncode == 0, f"Reflect command failed - Test ID: {test_uuid}"

        # Verify CLI structure output
        try:
            data = json.loads(result.stdout)
            assert isinstance(data, dict), f"Reflect should return object - Test ID: {test_uuid}"
            assert len(data) > 20, f"Reflect should discover many commands - Test ID: {test_uuid}"
        except json.JSONDecodeError:
            pytest.fail(f"Reflect command returned invalid JSON - Test ID: {test_uuid}")

    def test_quick_deploy_tool_cli_execution(self, test_uuid: str) -> None:
        """Test that quick-deploy tool can execute the underlying CLI command."""
        # Test with --help first (safer than actual deployment)
        result = subprocess.run(["tmux-orc", "quick-deploy", "--help"], capture_output=True, text=True, timeout=5)

        assert result.returncode == 0, f"Quick-deploy help failed - Test ID: {test_uuid}"
        assert "Usage:" in result.stdout, f"Quick-deploy help missing usage - Test ID: {test_uuid}"

    def test_spawn_orc_tool_cli_execution(self, test_uuid: str) -> None:
        """Test that spawn-orc tool can execute the underlying CLI command."""
        # Test with --help (safer than actual spawning)
        result = subprocess.run(["tmux-orc", "spawn-orc", "--help"], capture_output=True, text=True, timeout=5)

        assert result.returncode == 0, f"Spawn-orc help failed - Test ID: {test_uuid}"
        assert "Usage:" in result.stdout, f"Spawn-orc help missing usage - Test ID: {test_uuid}"

    def test_execute_tool_cli_execution(self, test_uuid: str) -> None:
        """Test that execute tool can execute the underlying CLI command."""
        # Test with --help (safer than actual execution)
        result = subprocess.run(["tmux-orc", "execute", "--help"], capture_output=True, text=True, timeout=5)

        assert result.returncode == 0, f"Execute help failed - Test ID: {test_uuid}"
        assert "Usage:" in result.stdout, f"Execute help missing usage - Test ID: {test_uuid}"


class TestMCPToolPerformance:
    """Test performance of auto-generated MCP tools."""

    def test_tool_cli_commands_performance(self, test_uuid: str) -> None:
        """Test that underlying CLI commands meet performance requirements."""
        commands_to_test = [
            (["tmux-orc", "list", "--json"], 1.5),  # 1.5s max
            (["tmux-orc", "status", "--json"], 2.0),  # 2.0s max
            (["tmux-orc", "reflect", "--format", "json"], 1.5),  # 1.5s max
        ]

        for cmd, max_time in commands_to_test:
            start_time = time.perf_counter()

            result = subprocess.run(cmd, capture_output=True, text=True, timeout=5)

            execution_time = time.perf_counter() - start_time

            assert result.returncode == 0, f"Command {' '.join(cmd)} failed - Test ID: {test_uuid}"
            assert (
                execution_time < max_time
            ), f"Command {' '.join(cmd)} took {execution_time:.3f}s (>{max_time}s) - Test ID: {test_uuid}"

    def test_mcp_server_startup_performance(self, test_uuid: str) -> None:
        """Test that MCP server starts and generates tools quickly."""
        start_time = time.perf_counter()

        result = subprocess.run(
            ["timeout", "10", "python", "-m", "tmux_orchestrator.mcp_server"], capture_output=True, text=True
        )

        execution_time = time.perf_counter() - start_time

        # Should discover and generate tools in <10s
        assert execution_time < 10.0, f"MCP server startup took {execution_time:.3f}s (>10s) - Test ID: {test_uuid}"

        # Should have generated all 6 tools
        assert "Generated MCP Tools" in result.stderr, f"No tools generated - Test ID: {test_uuid}"
        assert "Starting FastMCP server" in result.stderr, f"Server failed to start - Test ID: {test_uuid}"


class TestMCPClientCompatibility:
    """Test MCP client compatibility and integration."""

    def test_mcp_tool_json_schema_compatibility(self, test_uuid: str) -> None:
        """Test that MCP tools produce JSON compatible with MCP clients."""
        # Test that CLI commands produce valid JSON for MCP consumption
        commands = [
            ["tmux-orc", "list", "--json"],
            ["tmux-orc", "status", "--json"],
            ["tmux-orc", "reflect", "--format", "json"],
        ]

        for cmd in commands:
            result = subprocess.run(cmd, capture_output=True, text=True, timeout=5)

            if result.returncode == 0 and result.stdout:
                try:
                    # Verify JSON is valid and serializable
                    data = json.loads(result.stdout)
                    json.dumps(data)  # Should not raise exception

                    # Verify data types are MCP-compatible
                    assert (
                        isinstance(data, (dict, list, str, int, float, bool)) or data is None
                    ), f"Command {' '.join(cmd)} returned non-MCP-compatible data - Test ID: {test_uuid}"

                except json.JSONDecodeError:
                    pytest.fail(f"Command {' '.join(cmd)} returned invalid JSON - Test ID: {test_uuid}")

    def test_mcp_tool_error_handling(self, test_uuid: str) -> None:
        """Test that MCP tools handle errors gracefully."""
        # Test invalid commands that should fail gracefully
        result = subprocess.run(["tmux-orc", "list", "--invalid-flag"], capture_output=True, text=True, timeout=5)

        # Should fail gracefully (non-zero exit but no crash)
        assert result.returncode != 0, f"Invalid command should fail - Test ID: {test_uuid}"

        # Should have error output (not crash)
        assert (
            len(result.stderr) > 0 or len(result.stdout) > 0
        ), f"No error output from invalid command - Test ID: {test_uuid}"

    def test_mcp_server_fastmcp_compatibility(self, test_uuid: str) -> None:
        """Test that MCP server is compatible with FastMCP protocol."""
        # Verify server uses FastMCP
        result = subprocess.run(
            ["timeout", "3", "python", "-m", "tmux_orchestrator.mcp_server"], capture_output=True, text=True
        )

        # Should initialize FastMCP server successfully
        assert (
            "Initializing fresh CLI reflection MCP server" in result.stderr
        ), f"MCP server not initializing - Test ID: {test_uuid}"
        assert "Starting FastMCP server" in result.stderr, f"FastMCP server not starting - Test ID: {test_uuid}"


class TestMCPToolIntegration:
    """Test integration scenarios for auto-generated MCP tools."""

    def test_tool_chain_workflow(self, test_uuid: str) -> None:
        """Test a workflow using multiple MCP tools in sequence."""
        # Workflow: reflect -> list -> status

        # 1. Reflect to discover CLI structure
        reflect_result = subprocess.run(
            ["tmux-orc", "reflect", "--format", "json"], capture_output=True, text=True, timeout=5
        )
        assert reflect_result.returncode == 0, f"Reflect failed in workflow - Test ID: {test_uuid}"

        # 2. List agents
        list_result = subprocess.run(["tmux-orc", "list", "--json"], capture_output=True, text=True, timeout=5)
        assert list_result.returncode == 0, f"List failed in workflow - Test ID: {test_uuid}"

        # 3. Get status
        status_result = subprocess.run(["tmux-orc", "status", "--json"], capture_output=True, text=True, timeout=5)
        assert status_result.returncode == 0, f"Status failed in workflow - Test ID: {test_uuid}"

        # Verify data consistency between list and status
        try:
            list_data = json.loads(list_result.stdout)
            status_data = json.loads(status_result.stdout)

            # Agent count should match
            assert len(list_data) == len(
                status_data.get("agents", [])
            ), f"Agent count mismatch between list and status - Test ID: {test_uuid}"

        except json.JSONDecodeError:
            pytest.fail(f"Workflow produced invalid JSON - Test ID: {test_uuid}")

    def test_concurrent_tool_execution(self, test_uuid: str) -> None:
        """Test that multiple MCP tools can be executed concurrently."""
        import concurrent.futures

        def run_command(cmd):
            return subprocess.run(cmd, capture_output=True, text=True, timeout=10)

        commands = [
            ["tmux-orc", "list", "--json"],
            ["tmux-orc", "status", "--json"],
            ["tmux-orc", "reflect", "--format", "json"],
        ]

        # Execute commands concurrently
        with concurrent.futures.ThreadPoolExecutor(max_workers=3) as executor:
            futures = [executor.submit(run_command, cmd) for cmd in commands]
            results = [future.result() for future in concurrent.futures.as_completed(futures)]

        # All should succeed
        for i, result in enumerate(results):
            assert result.returncode == 0, f"Concurrent command {i} failed - Test ID: {test_uuid}"


if __name__ == "__main__":
    pytest.main([__file__, "-v"])
